from flask import Flask, request, jsonify
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
import shap
import lime
import lime.lime_tabular
import traceback
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# D·ªØ li·ªáu m·∫´u m√¥n h·ªçc
courses = {
    'Math': {'credits': 3, 'difficulty': 0.8},
    'Reading': {'credits': 3, 'difficulty': 0.6},
    'Writing': {'credits': 3, 'difficulty': 0.7},
    'Biology': {'credits': 3, 'difficulty': 0.5},
}

# H√†m d·ª± ƒëo√°n x√°c su·∫•t c·ª•m cho LIME
def predict_probabilities(model, X):
    if model is None:
        return np.array([[0.5, 0.5]])  # Tr√°nh l·ªói khi model ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o
    clusters = model.predict(X)
    probs = np.zeros((X.shape[0], model.n_clusters))
    for i, cluster in enumerate(clusters):
        probs[i, cluster] = 1
    return probs

# H√†m ph√¢n t√≠ch ƒëi·ªÉm s·ªë v√† ƒë∆∞a ra khuy·∫øn ngh·ªã
def recommend_courses(grades_df, grades):
    recommendations = [subject for subject, score in grades.items() if score < 7]
    if not recommendations:
        available_courses = [c for c in courses.keys() if c not in grades.keys()]
        recommendations = available_courses[:2]

    kmeans_model = None
    if grades_df.shape[0] > 1:
        n_clusters = min(2, len(grades_df))
        kmeans_model = KMeans(n_clusters=n_clusters, random_state=0, n_init=3).fit(grades_df)
    return recommendations, kmeans_model

# H√†m gi·∫£i th√≠ch b·∫±ng SHAP v√† LIME
def explain_recommendations(grades_df, recommendations, kmeans_model, grades):
    explanations, shap_explanation, lime_explanation = [], [], []

    for rec in recommendations:
        if rec in grades:
            explanations.append(f"{rec} ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t v√¨ ƒëi·ªÉm s·ªë c·ªßa b·∫°n l√† {grades[rec]}, th·∫•p h∆°n ng∆∞·ª°ng y√™u c·∫ßu (7).")
        else:
            explanations.append(f"{rec} ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t v√¨ ƒë√¢y l√† m√¥n h·ªçc m·ªõi, c√≥ ƒë·ªô kh√≥ {courses[rec]['difficulty']} ph√π h·ª£p v·ªõi b·∫°n.")

    if kmeans_model is not None:
        feature_names = list(grades_df.columns)
        X = grades_df.values
        
        background = grades_df.sample(n=1, random_state=42).values
        explainer_shap = shap.KernelExplainer(kmeans_model.predict, background)
        shap_values = explainer_shap.shap_values(X)

        for i, feature in enumerate(feature_names):
            shap_value = shap_values[0][i]
            if shap_value > 0:
                shap_explanation.append(f"{feature} (ƒëi·ªÉm s·ªë: {grades[feature]}) c√≥ ·∫£nh h∆∞·ªüng l·ªõn (SHAP value: {shap_value:.2f})")

        explainer_lime = lime.lime_tabular.LimeTabularExplainer(
            training_data=X, feature_names=feature_names, mode='classification', random_state=0
        )
        lime_exp = explainer_lime.explain_instance(X[0], lambda x: predict_probabilities(kmeans_model, x), num_features=2)
        lime_explanation = lime_exp.as_list()
    
    return explanations, shap_explanation, lime_explanation

@app.route('/analyze', methods=['POST'])
def analyze():
    try:
        data = request.json
        print("üì• Nh·∫≠n d·ªØ li·ªáu t·ª´ frontend:", data)

        students = data.get("students", [])
        if not students:
            return jsonify({"error": "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá, c·∫ßn √≠t nh·∫•t m·ªôt sinh vi√™n."}), 400

        all_grades = {s["studentID"]: s["grades"] for s in students}
        grades_df = pd.DataFrame([s["grades"] for s in students])
        print("üìù DataFrame:", grades_df)

        results = []
        for student in students:
            student_id, grades = student["studentID"], student["grades"]
            recommendations, kmeans_model = recommend_courses(grades_df, grades)
            explanations, shap_explanation, lime_explanation = explain_recommendations(grades_df, recommendations, kmeans_model, grades)

            results.append({
                "studentID": student_id,
                "recommendedCourses": recommendations,
                "explanations": explanations,
                "shapExplanation": shap_explanation,
                "limeExplanation": [str(exp) for exp in lime_explanation]
            })

        print("‚úÖ Ph·∫£n h·ªìi:", results)
        return jsonify(results)

    except Exception as e:
        print("‚ùå L·ªói backend:", e)
        print(traceback.format_exc())
        return jsonify({"error": "L·ªói server", "details": str(e)}), 500

if __name__ == '__main__':
    app.run(port=5000)
